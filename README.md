# 内存管理 - 请求调页存储管理方式模拟报告

### 1951748 罗力信

#### [点击此处以运行](https://user3984.github.io/)

## Project setup
```
npm install
```

### Compiles and hot-reloads for development
```
npm run serve
```

### Compiles and minifies for production
```
npm run build
```

### Customize configuration
See [Configuration Reference](https://cli.vuejs.org/config/).

## 目录

- 项目需求  
  - 模拟条件
  - 模拟过程
- 开发环境
- 操作说明
- 算法说明
  - 最佳算法 (OPT)
  - 先进先出算法 (FIFO)
  - 最近最少使用页面淘汰算法 (LRU)
  - 最不常用算法 (LFU)
  - 轮转算法 (Clock)
- 实验结果与分析



## 项目需求

 本项目需要**实现请求调页存储管理方式的多种算法**并**利用随机生成的 320 条指令测试不同算法的缺页率**。

#### 模拟条件

- 每个页面可存放10条指令，分配给一个作业的内存块为4
- 模拟一个作业的执行过程，该作业有320条指令，即其地址空间为32页，初始时所有页均未调入内存
- 模拟作业中，50%的指令是顺序执行的，25%是均匀分布在前地址部分，25％是均匀分布在后地址部分，指令的生成方式如下：
  - 在0－319条指令之间，随机选取一个起始执行指令，如序号为 $m$
  - 顺序执行下一条指令，即序号为 $m+1$ 的指令
  - 通过随机数，跳转到前地址部分 0 ~ $m-1$ 中的某个指令处，其序号为 $m_1$
  - 顺序执行下一条指令，即序号为 $m_1+1$ 的指令
  - 通过随机数，跳转到后地址部分 $m_1+2$ ~ 319 中的某条指令处，其序号为 $m_2$
  - 顺序执行下一条指令，即 $m_2+1$ 处的指令
  - 重复跳转到前地址部分、顺序执行、跳转到后地址部分、顺序执行的过程，直到执行完 320 条指令

#### 模拟过程

- 模拟过程中，如果所访问指令在内存中，则显示其物理地址，并转到下一条指令
- 如果没有在内存中，则发生缺页，此时需要记录缺页次数，并将其调入内存
- 如果4个内存块中已装入作业，则需进行页面置换
- 所有320条指令执行完成后，计算并显示作业执行过程中发生的缺页率



## 开发环境

- **开发环境：** Windows 10 21H1 Intel(R) Core(TM) i7-9750H @ 2.60GHz
- **开发软件：** Visual Studio Code
- **开发语言：** JavaScript, HTML, CSS
- **主要引用包：** Vue框架, Element-UI



## 操作说明

操作界面如下图所示

![image-20210612233338572](C:\Users\22872\AppData\Roaming\Typora\typora-user-images\image-20210612233338572.png)

![image-20210612234108173](C:\Users\22872\AppData\Roaming\Typora\typora-user-images\image-20210612234108173.png)

- 首先点击“**开始模拟**”按钮，点击后系统将根据设定的规则随机生成访问的指令序列，并分别用 5 种算法进行模拟，并统计在 320 条指令的执行过程中各算法的缺页次数及缺页率，结果显示在左侧“模拟结果”栏中
- 界面右侧为每执行一条指令时各内存块中存储的页号，点击下拉框可以选择查看不同算法执行过程中的内存块的变化情况。选择后点击“**查看**”按钮以查看。
- 右表中的各项含义如下：
  - 逻辑地址：指令的逻辑地址
  - 物理地址：若不发生缺页，则该指令已经在内存中，其物理地址即为其在内存中的地址；若发生缺页，则需要进行调页操作，将该指令所在的页调入某个内存块中，此时的物理地址即为该页面被调入内存后该指令在内存中的地址，其计算方式为：**物理地址 = 逻辑地址 % 10 + 内存块号 * 10**
  - 是否缺页：该指令所在的页面是否已经在内存中。若不在内存中，则发生缺页
  - 内存块 i : 内存块 i 中存储的页面号。若**该块为空**（未调入任何页面）**则记为 -1**



## 算法说明

请求调页算法的基本框架如下：

1. 若要访问的页面已经在内存中，则无需调页；

2. 若要访问的页面不在内存中，则发生缺页，需要进行调页。

   (1) 若内存未满，则直接将该页调入一个空的内存块中；

   (2) 若内存已满，则**根据页面置换算法选择一个内存中的页面调出到外存中，再将要访问的页面调入到该内存块中**。

本项目设置了 5 种页面置换算法，分别为**最佳算法 (OPT)**、**先进先出算法 (FIFO)**、**最近最少使用页面淘汰算法 (LRU)**、**最不常用算法 (LFU)**及**轮转算法 (Clock)**。

#### 最佳算法 (OPT)

最佳算法的思想是：每次**淘汰的页面**是**以后永不使用**或者**在最长时间内不再被访问**的页面，以保证最低的缺页率。

算法的流程可描述如下：

- 对于内存中的每一个页面，向后扫描之后执行的指令，确定该页面下次使用的时间
- 选取之后不再使用或下次使用时间最后的页面，将其换出外存

OPT算法的代码实现如下

```javascript
var replacePage = 0; // 被替换的页所在的内存块号
var maxt = 0; // 最长的下次使用时间
for (var j = 0; j < 4; ++j) {
    var t; // 下次使用时间
    for (t = i + 1; t < 320; ++t) {
        if (this.page[t] === memory[j]) {
            break;
        }
    }
    if (t === 320) {
        // 之后不再使用
        replacePage = j;
        break;
    }
    if (t > maxt) {
        maxt = t;
        replacePage = j;
    }
}
memory[replacePage] = this.page[i]; // 替换
```

最佳算法是一种理想的算法。在实际中，**由于无法预知之后执行的指令，因此上述的最佳算法是无法实现的。**

#### 先进先出算法 (FIFO)

先进先出置换算法的思想是：每次选择淘汰的页面是**最早进入内存的页面**。

算法的实现需要使用一个队列。将调入内存的页面**根据调入的先后顺序排成一个队列**，需要换出页面时**选择队头的页面换出**。调入新的页面后，需要将新的页面加入到队尾。

FIFO算法的代码实现如下：

```javascript
var replacePage = queue.shift();
memory[replacePage] = this.page[i]; // 替换
queue.push(replacePage);
```

#### 最近最少使用页面淘汰算法 (LRU)

最近最少使用页面淘汰算法的思想是：每次淘汰的页面是**最近最久未使用的页面**。

算法的实现需要一个辅助的数组，记录内存中每个页面上次访问时间。当要淘汰一个页面时，选择内存中上次访问时间最早的页面，即最久未使用的页面。

算法的代码实现如下：

```javascript
var replacePage = 0; // 被替换的页所在的内存块号
var minLastUse = 320; // 最早的上次使用时间
for (var j = 0; j < 4; ++j) {
    if (lastUse[j] < minLastUse) {
        minLastUse = lastUse[j];
        replacePage = j;
    }
}
memory[replacePage] = this.page[i]; // 替换
lastUse[replacePage] = i;
```

#### 最不常用算法 (LFU)

最不常用算法的思想是：每次淘汰的页面是自调入以来**被访问次数最少的页面**。

算法的实现需要一个辅助的数组，用于记录内存中每个页面自调入以来的被访问次数。每当页面被访问时，该页面的访问计数器加1。当要淘汰一个页面时，选择内存中计数值最小的页面。

算法的代码实现如下：

```javascript
var replacePage = 0; // 被替换的页所在的内存块号
var minUse = 321; // 最少使用次数
for (var j = 0; j < 4; ++j) {
    if (useCount[j] < minUse) {
        minUse = useCount[j];
        replacePage = j;
    }
}
memory[replacePage] = this.page[i]; // 替换
useCount[j] = 1;
```

#### 轮转算法 (Clock)

轮转算法又称**时钟置换算法**或**最近未使用算法** (NRU, Nor Recently Used)，其实现方式为：

**为每个页面设置一个访问位**，并将内存中的页面都**通过链接指针链接成一个循环队列**。当某页面被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。若访问位为0，则选择该页换出；若访问位为1，则将其置为0，暂不换出，继续检查下一个页面，直到扫描到一个访问位为0的页面，将其换出。

算法的代码实现如下：

```javascript
while (1) {
    if (refbits[p] === 1) {
        refbits[p] = 0; // 访问位置为0
        p = (p + 1) % 4; // 循环指向下一个页面
    }
    else {
        memory[p] = this.page[i]; // 替换
        refbits[p] = 1;
        p = (p + 1) % 4; // 循环指向下一个页面
    }
```

## 实验结果与分析

通过多次实验可以发现，OPT 算法的缺页次数与缺页率明显低于其他 4 种算法。然而在实际中，由于无法预知之后执行的指令，因此 OPT 算法是无法实现的。

对于另外4种算法，由于指令数量偏少，4种算法在缺页次数、缺页率上的差异并不显著。通过大量重复实验，总体上呈现出以下规律：

- FIFO 算法缺页率略高于其余三种算法
- LRU 与 LFU 算法缺页率较低
- Clock 算法的缺页率介于 FIFO 算法与 LRU / LFU 算法之间

4 种算法中，FIFO 算法的实现最为简单，但其性能较差，**容易发生抖动现象**，而且会出现 **Belady 异常**，即当为进程分配的物理块数增大时，缺页次数不减反增。且 FIFO 算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问，因此性能较差。LRU 算法与 LFU 算法尽管性能较好，但其实现**需要专门的硬件支持**，实现较为困难，**开销较大**。而 Clock 算法则是一种**性能与开销较为均衡**的算法。
